## Java-JVM

### Jvm虚拟机

- Jvm内存区域：

    - 运行时数据区（堆、栈、方法区）
    - 类加载子系统（Class Loader）
    - 执行引擎（即时编译器JITCompiler、垃圾收集GC）
    - 本地库接口（JNI 加载本地方法）

- 堆

  对象在堆上创建

    - 新生代
        - Eden区
        - From Survivor区
        - To Survivor区
    - 老年代

- 栈（线程私有）

    - 虚拟机栈。栈帧结构如下：
        - 局部变量表

        - 操作数栈

        - 动态链接（应该是常量池引用）

          每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接（Dynamic Linking）。

          在类加载阶段中的解析阶段会将符号引用转为直接引用，这种转化也称为静态解析。另外的一部分将在每一次运行时期转化为直接引用，这部分称为动态连接。

        - 方法出口

    - 本地方法栈

    - 程序计数器（针对Native方法为空。唯一不会OOM的区域）

- 方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式。

- 永久代（1.8之前）

  存储被JVM加载的类信息、常量（常量池）、静态变量、即时编译器编译后的代码等数据

- 元空间（1.8替代永久代）

  数据位置的变化：类的元数据放入 native memory（元空间）, 字符串池和类的静态变量放入 java 堆中

### 垃圾回收

- 确定垃圾的方法：引用计数（无法解决循环引用）、可达性分析（通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可达的。GC Roots
  一般包含：虚拟机栈中局部变量表中引用的对象、本地方法栈中 JNI 中引用的对象、方法区中类静态属性引用的对象、方法区中的常量引用的对象、所有被同步锁持有的对象。不可达对象变为可回收对象至少要经过两次标记过程）

- 垃圾清除算法：标记-清除算法、复制算法、标记-整理。一般采用分代收集算法

- 部分收集 (Partial GC)：

    - 新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；
    - 老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；
    - 混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。

  整堆收集 (Full GC)：收集整个 Java 堆和方法区。

- 对象优先在Eden区分配、大对象直接进入Old Memory、长期存活的对象进入Old Memory、晋升年龄动态计算、空间分配担保（确保在 Minor GC 之前老年代本身还有容纳新生代所有对象的剩余空间）

- 对象进入老年代的几种情况：大对象直接进、年龄够了进、动态年龄判断、MiniorGC后Survivor容纳不了存活的对象

- 何时会出现Full GC：空间分配担保机制。老年代满了（不够装要放进去的对象）。主动System.gc()

- 四种引用类型：强引用、软引用、弱引用、虚引用（不能单独使用也不能通过它访问对象，必须和引用队列(ReferenceQueue)联合使用）

  创建虚引用的时候可以指定关联的队列，当Gc释放对象内存的时候，会将引用加入到引用队列，如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动，这相当于是一种通知机制。

- 垃圾收集器：Serial、ParNew、Parallel Scavenge、Serial Old、Parallel Old、CMS、G1、ZGC

- CMS（标记-清除算法、老年代收集器）：初始标记、并发标记、重新标记、并发清除
    - 第一步是初始标记：初始标记的话，只标记GC root直接引用的对象，只有很少一部分，这个阶段需要STW，但是影响不大，这个过程特别快。这个过程也可以优化，JVM 有个参数是初始标记阶段多线程标记，减少STW时间，正常是单线程标记的。

    - 第二步是并发标记：这个阶段是不需要STW的，是和系统并行的处理，系统继续运行，然后垃圾回收线程去追踪第一步标记的GC
      root，这一步是很耗时的，但是不影响程序执行。因为在垃圾回收时是允许系统继续创建对象的，所以这个过程会有新的对象进来，也会有标记存活的但是现在变成垃圾，这些有改动的对象JVM都会记下来，等待下一步处理。这一步有一个缺点，并发清理时也有这个问题，就是会占用CPU资源。如果是一个4核的机器，那会占用一个CPU去垃圾回收，公式是 **(
      cpu核数 + 3)/4**。所以一般CPU资源负载特别高的时候，就俩情况，要不是程序的线程太多了。要不就是频繁FullGC，导致的。

    - 第三步是重新标记：重新标记阶段，会把并发标记阶段有改动的对象重新标记，这一步需要STW，不过也是比较快的，因为改动的对象不会特别多，但是要比第一步慢因为要重新判断找个对象是否GC可达。这里也可以通过JVM参数优化，可以通过参数控制，让CMS在重新标记阶段之前尽量触发一次Young GC(
      尽量YoungGC是因为可能新生代可能刚刚YoungGC不久，那此时就没必要再一次YoungGC了)这样做的好处是，改动的对象中从存活变为垃圾的那部分，就被清理掉了，缩短STW时间。虽然YoungGC也会造成停顿，但是YoungGC一般频率是比较快的，早晚都要执行，现在执行一举两得。

    - 第四步是并发清理，并发清理是和系统并行的，不需要STW。这个阶段是清理前几个阶段标记好的垃圾。

  CMS以获取最短回收停顿时间为目标，适合内存大、CPU核数多的服务器端应用。

  也被称为标记-清除 + 整理 算法，一般在JVM参数会指定这算法和整理的频率，JVM参数默认是，标记-清除，5次之后，才会去整理内存空间，让对象整齐排列。

  优点：并发收集低停顿。

  缺点：

    - 吞吐量低，低停顿时间是以牺牲吞吐量为代价的，并发执行，对CPU资源压力大。

    - 无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS
      收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，将触发担保机制，Serial Old 收集器将会以STW的方式进行一次GC，从而造成较大停顿时间。

    - 标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。

  可与Serial、ParNew配合使用。

  [CMS GC问题分析及解决](https://www.lwohvye.com/2021/06/13/java%e4%b8%ad9%e7%a7%8d%e5%b8%b8%e8%a7%81%e7%9a%84cms-gc%e9%97%ae%e9%a2%98%e5%88%86%e6%9e%90%e4%b8%8e%e8%a7%a3%e5%86%b3/)
- G1（整体上采用标记-整理算法，局部通过复制算法）：不产生内存碎片、优先回收垃圾最多的区域，可精准控制停顿时间、只有逻辑上的分代概念

    - 通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region
      垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。

    - 每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。

    - G1的垃圾回收不一定是年轻代满了，或者老年代满了才去回收。基于停顿时间的需求，会在一些合适的时机触发回收，所以这存在不可控性。

    - 收集过程：初始标记、并发标记、最终标记、筛选回收。

    - G1中大对象不会进入老年代，而是专门有一部分Region存放大对象用。如果一个Region放不下大对象，那就会横跨几个Region来存放。

    - G1的混合回收：如果老年代占比45%，就会触发混合回收，回收整个堆内存，但是混合回收也是会控制在我们设置的停顿时间的范围内的，如果时间不够，就会分多次回收。JVM参数可以设置这个值，分几次去回收， **默认值是8次，分8次回收**
      。混合回收还有一个参数我们可以设置，就是空闲的Region达到百分之多少，停止回收，默认是5%。

    - G1的优化：G1比较智能，我们可以参与优化的点很少（ParNew +CMS可优化到极致），我们只能合理的设置停顿时间，不要太小也不要太大，太小GC会太频繁，每秒都在GC。太大的话，停顿时间太久了也不好。

  程序运行中安全点的概念。

- GC日志怎么看？jstat -gc PID 1000 100 每秒打印一次，打印100次
    - S0C：Survivor0 的大小
    - S1C：Survivor1 的大小
    - S0U：Survivor0 使用了多少
    - S1U：Survivor1 使用了多少
    - EC：Eden 区的大小
    - EU：Eden 区使用了多少
    - OC：老年代的大小
    - OU：老年代使用了多少
    - MC：永久代的大小
    - MU：永久代使用了多少
    - YGC：YoungGC次数
    - YGCT：YoungGC的总耗时
    - FGC：Full GC次数
    - FGCT：Full GC的总耗时

  一般使用 jstat 优化，重点观察这几个指标
    - Eden 区对象的增长速度：上面的几列，通过一行数据是看不出来Eden 区每秒增长多少数据的，所以我们才每秒打印一次，通过上一秒和下一秒EU的数据就可以推断出每秒增长了多少。这个数据进来多打印几行，取个平均值。
    - Young GC
      频率：我们知道系统启动时间，用YGC的大小除也能算，但是谁没事记得系统什么时候启动的。而且如果我想看高峰时期某一段时间的呢，就看不了了。看几十天的平均值也没什么意义。所以这个高峰时段YoungGC的频率是通过，Eden的大小，除以Eden区对象的增长速度来算的，Eden区对象增长速度，我们已经知道了。
    - Young GC 耗时：这个YoungGC耗时，我们取平均值就行，用YGCT除以YCG，时间除以次数就是每次的耗时。如果说就像看高峰时段的，因为CPU等使用率比较高，可能会影响回收时间，也可以单独看几次的YoungGC，算出时间。
    - Young GC 后多少对象存活：这个指标还是比较重要的，我们要确定每次存活的对象Survovir到底能不能放得下。我们要保证每次存活的对象要小于Survivor的50%，否则就会触发动态年龄审核机制。
    - 老年代对象增量速度：老年代对象增长速度，决定了Old GC的频率。发生Old GC后，FGC那一列也会增长，FGC那一列其实是FullGC 和Old
      GC的总和。经过优化后的JVM，每次YoungGC不应该进入太多的对象，不进入或者每次进入几兆是比较好的。这个指标我们也要分多次观察，因为只看一次YoungGC晋升的大小是片面的。我们现在已经知道了YoungGC的频率，如果是3分钟一次，那我们就3分钟打印一次内存情况。jstat -gc PID
      180000
      100，取多次晋升大小的平均值就行。如果晋升的对象特别多，我们需要分析这些对象为什么会进入老年代，上面我说了有四种情况会晋升老年代，到底是哪种情况。是Survivor不够大，还是大对象太多了，或者有内存泄漏导致对象回收不掉，进入了老年代。这个还要具体分析一下的。如果是Survivor太小，我们很轻易就能看出来，如果每次Young
      GC后S区都是0，那说明存活的对象太多，S区放不下，都进入了老年代。如果S区不是0，有一部分，但是每次回收进入老年代都很多，就有可能是触发动态年龄审核，这个最好再通过GC日志看一下，通过JVM参数可以让系统打印每次GC的日志。如果出现内存泄漏，数据一般是这样的，发现每次FGC次数加1后，老年代并没有多少数据被回收掉，占用了很多。这就大概率是内存泄漏，导致老年代回收不掉。如果是大对象，数据会这样显示，发现及时没有Young
      GC，OU也会一直在涨，因为大对象是不用经过年轻代的直接进入老年代。如果内存泄漏和大对象的情况，我们可以用 jmap 打印一份内存快照，用MAT工具分析一下到底是什么对象特别大，通过分析出来的堆栈信息就可以定位到代码的位置。
    - Full GC 频率多高：看这个频率和看YoungGC的频率是一样的，可以看高峰时期某几次的平均值。这个Full GC是很耗时的，Full GC的频率我们最好控制在一天1次或者几天一次的范围。特别是对时效性要求比较高的系统，一定要减少Full GC次数。
    - 一次Full GC 的耗时：这个可以取平均值，也可以取某一段的。我们会发现这个Full GC的耗时是YoungGC的好多倍
- GC之约定参数说明

    - DefNew：Default New Generation
    - Tenured：Old
    - ParNew：Parallel New Generation
    - PSYoungGen：Parallel Scavenge
    - ParOldGen：Parallel Old Generation

- STW: Stop The World

- Parallel Scavenge重点关注的是可控制的吞吐量，有自适应调节策略

- 方法区的回收

  因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。

  主要是对常量池的回收和对类的卸载。

  为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能。

  类的卸载条件很多，需要满足以下三个条件，并且满足了条件也不一定会被卸载：

    - 该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。
    - 加载该类的 ClassLoader 已经被回收。
    - 该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。

#### JVM调优

- [调优相关及工具](https://www.lwohvye.com/2022/03/13/jvm%e6%80%a7%e8%83%bd%e8%b0%83%e4%bc%98/)

### 类加载

- 步骤：加载、连接（验证、准备、解析）、初始化、使用、卸载

    - 加载是类加载的一个阶段，注意不要混淆。

      加载过程完成以下三件事：

        - 通过类的完全限定名称获取定义该类的二进制字节流。
        - 将该字节流表示的静态存储结构转换为方法区的运行时存储结构。
        - 在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口。

      其中二进制字节流可以从以下方式中获取：

        - 从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础。
        - 从网络中获取，最典型的应用是 Applet。
        - 运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。
        - 由其他文件生成，例如由 JSP 文件生成对应的 Class 类。

    - 验证：确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

      包括：文件格式验证、元数据验证、字节码验证、符号引用验证

    - 准备：类变量是被 static 修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存。（静态变量和常量池在方法区中，1.8时移到了堆中）

      实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。

    - 解析：将常量池的符号引用替换为直接引用的过程。

      解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符 7 类符号引用进行。

      符号引用就是一组符号来描述目标，可以是任何字面量。**直接引用**就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。

      其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定

    - 初始化：初始化阶段才真正开始执行类中定义的 Java 程序代码。初始化阶段是虚拟机执行类构造器 `<clinit>()` 方法的过程。在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。

      `<clinit>()` 是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。

      由于父类的 `<clinit>()` 方法先执行，也就意味着父类中定义的静态语句块的执行要优先于子类。

      接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 `<clinit>()` 方法。但接口与类不同的是，执行接口的 `<clinit>()` 方法不需要先执行父接口的 `<clinit>()`
      方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 `<clinit>()` 方法。

      虚拟机会保证一个类的 `<clinit>()` 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 `<clinit>()` 方法，其它线程都会阻塞等待，直到活动线程执行 `<clinit>()` 方法完毕。如果在一个类的 `<clinit>()`
      方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽。

- 类初始化时机

  主动引用

  虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了有且只有下列五种情况必须对类进行初始化（加载、验证、准备都会随之发生）：

    - 遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这 4 条指令的场景是：使用 new 关键字实例化对象的时候；读取或设置一个类的静态字段（被 final
      修饰、已在编译期把结果放入常量池的静态字段除外）的时候；以及调用一个类的静态方法的时候。
    - 使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。
    - 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
    - 当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类；
    - 当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化；

  被动引用

  以上 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的常见例子包括：

    - 通过子类引用父类的静态字段，不会导致子类初始化。
    - 通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。
    - 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。

- 类加载器：Bootstrap ClassLoader（启动类加载器）、Extension ClassLoader（扩展类加载器，Java 9更名为 Platform ClassLoader）、Application ClassLoader（应用程序类加载器/系统类加载器）

- java9之前的classloader

    - bootstrap classloader加载rt.jar，jre/lib/endorsed
    - ext classloader加载jre/lib/ext
    - application classloader加载-cp指定的类

  java9及之后的classloader

    - bootstrap classloader加载lib/modules
    - ext classloader更名为platform classloader，加载lib/modules（与bootstrap有所分工）
    - application classloader加载-cp，-mp指定的类

  启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可。

- 双亲委派机制。由类加载器和类名唯一确定一个类对象。

- 双亲委派模型的作用

    - 作用：保证JDK核心类的优先加载；

  如何打破双亲委派模型

    - 自定义类加载器，重写loadClass方法；

    - 使用线程上下文类加载器；

### 对象

- Java对象创建过程：类加载检查、分配内存、初始化零值、设置对象头、执行init方法

- 内存分配的两种方式：指针碰撞、空闲列表

- 内存分配并发问题

  在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：

    - **CAS+失败重试：** CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。**虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。**
    - **TLAB：** 为每一个线程预先在 Eden 区分配一块内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配

- 字符串常量池的一些问题：

  字符串对象的创建

    - new String都是在堆上创建字符串对象。当调用 intern() 方法时，编译器会将**首次**遇到的字符串添加到常量池中（stringTable维护），并返回指向该常量的引用。
    - 通过字面量赋值创建字符串（如：String str=”twm”）时，会先在常量池中查找是否存在相同的字符串，若存在，则将栈中的引用直接指向该字符串；若不存在，则在常量池中生成一个字符串，再将栈中的引用指向该字符串。
    - 常量字符串的“+”操作，编译阶段直接会合成为一个字符串。如string str=”JA”+”VA”，在编译阶段会直接合并成语句String str=”JAVA”，于是会去常量池中查找是否存在”JAVA”,从而进行创建或引用。
    - 对于final字段，编译期直接进行了常量替换（而对于非final字段则是在运行期进行赋值处理的）。

  ```java
      final String str1=”ja”;
      final String str2=”va”;
      String str3 = str1 + str2;
      // 在编译时，直接替换成了String str3=”ja”+”va”，根据第三条规则，再次替换成String str3=”java”
      String str1 = "a";
      String str2 = "b";
      String str4 = str1 + str2; //该语句只在堆中生成一个对象(str4)
      // 这句被Java编译器做了优化, 实际上使用StringBuilder实现的(不在堆里生成str1和str2对象)
  ```

    - 常量字符串和变量拼接时（如：String str3=baseStr + “01”;）会调用stringBuilder.append()在堆上创建新的对象
    - JDK
      1.7开始，intern方法还是会先去查询常量池中是否有已经存在，如果存在，则返回常量池中的引用，这一点与之前没有区别，区别在于，如果在常量池找不到对应的字符串，则不会再将字符串拷贝到常量池，而只是在常量池中生成一个对原字符串的引用。简单的说，就是往常量池放的东西变了：原来在常量池中找不到时，复制一个副本放到常量池，1.7后则是将在堆上的地址引用复制到常量池。

  ```java
  // 在JDK 6中，以下会是两个false，但JDK 7开始，第一个true，第二个false，因为`java`这个字符串比较特殊，在JDK的类库中有定义该字符串，在初始化时已经被加载，下面在toString()时已不是首次遇到了。
  // 类似的，若在str1之前定义一个值为`58tc`的字符串，后面也会返回false
  public class StringInternDemo {
  	public static void main(String[] args) {
  		String str1 = new StringBuilder("58").append("tc").toString();
  		System.out.println(str1);
  		System.out.println(str1.intern());
  		System.out.println(str1 == str1.intern()); 
      
  		System.out.println();
      
  		String str2 = new StringBuilder("ja").append("va").toString();
  		System.out.println(str2);
  		System.out.println(str2.intern());
  		System.out.println(str2 == str2.intern());
  	}
  }
  ```


- 创建对象时构造器的调用顺序是:先初始化静态成员（先父类），然后调用父类构造器，再初始化非静态成员，最后调用自身构造器。

### 类字节码相关

- [Java字节码](https://www.lwohvye.com/2021/05/24/java%e5%ad%97%e8%8a%82%e7%a0%81%e5%a2%9e%e5%bc%ba%e6%8e%a2%e7%a7%98/)

- Class编译后的字节码的结构等

  魔数、版本号、常量池、访问标志、当前类索引、父类索引、接口索引、字段表、方法表、附加属性

